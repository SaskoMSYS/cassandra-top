#!/bin/bash

# Program: cass_top
# Author: James Briggs
# Date: 2014 09 16
# Env: Linux bash
# License: Apache 2
# Usage: cass_top [host] [keyspace]

version="0.5"

# $1 = host     (default: localhost)
# $2 = keyspace (default: none)

# bash read timeout feature
timeout=1

# where to find commands
nodetool_cmd="nodetool"
grep_cmd="grep"

# use string functions to extract basename from the filename ($0)
program=${0##*/}

do_usage() {
   echo "usage: $program [connection_host] [keyspace]"
}

if [ -z "$1" ]; then
   c_host="localhost"
else
   if [ "$1" = "-h" ]; then
      do_usage
      exit
   fi
   c_host=$1
fi

c_keyspace=$2

append_auth() {
   cmd=$1
   # prepend authentication credentials if set in cassandra-env.sh
   [ -z "$JMX_USERNAME" ] || cmd="$cmd -u $JMX_USERNAME -pw $JMX_PASSWORD"

   echo -n "$cmd" # bash doesn't have a real function return capability, so echo the return value for capture by the caller
}

# prepend connection host
nodetool_full="$nodetool_cmd -h $c_host"

nodetool_full=$(append_auth "$nodetool_full")

clear_stdin() {
   read -t 1 -n 10000 discard_me # this is a bashism to clear stdin before asking for the real user input. Though adding a 1 second pause is not desirable.
}

press_any_key() {
   clear_stdin
   echo
   read -s -n 1 -p "Press any key to continue, Ctrl+C to quit... " anykey
   echo # acknowledge input to user
}

do_status() {
   s=$1

   if [ $s -eq 0 ]; then
      echo
      echo "info: nodetool was successful!"
   else
      echo
      echo "error: nodetool was not successful, exit status was $s"
   fi
}

do_banner() {
   echo "$program $version (c) James Briggs $(date), connecting to $c_host $c_keyspace...
$c_info"
}

do_help() {
   clear

   usage=$(do_usage)
   banner=$(do_banner)

   echo "$banner

$usage

Help for Interactive Commands

   Cluster-wide Commands

      c   nodetool cfstats [keyspace].[column family]
      C   nodetool cfhistograms keyspace column family
      f   nodetool flush [keyspace] [column family ...]
      r   nodetool ring [keyspace]
      G   nodetool getstreamthroughput |
                   getcompactionthroughput |
                   gossipinfo
      t   nodetool tpstats

   Node-specific Commands (target_host is a specific Cassandra node)

      d   nodetool -h target_host drain
      H   nodetool -h target_host compactionhistory
      i   nodetool -h target_host info
      j   nodetool -h target_host join
      K   nodetool -h target_host compact [keyspace] [column family ... ]
      l   nodetool -h target_host getLoggingLevels
      n   nodetool -h target_host netstats
      p   nodetool -h target_host proxyhistograms
      s   nodetool -h target_host compactionstats
      S   nodetool -h target_host statusbinary |
                                  statusthrift
      Z   nodetool -h target_host enableautocompaction |
                                  enablebackup |
                                  enablebinary |
                                  enablegossip |
                                  enablehandoff |
                                  enablethrift |
                                  disableautocompaction |
                                  disablebackup |
                                  disablebinary |
                                  disablegossip |
                                  disablehandoff |
                                  disablethrift |
                                  pausehandoff |
                                  resumehandoff

   Miscellaneous Commands

      h   help
      q   quit"

   press_any_key
   continue
}

do_exec() {
   option=$1

   echo
   echo "Running $nodetool_full $option..."
   echo
   $nodetool_full $option
   press_any_key
   continue
}

do_flush_exec() {
   keyspace=""
   cf=""

   clear_stdin
   read -e -p "Which keyspace do you want to flush? [ALL]: " keyspace

   if [ -n "$keyspace" ]; then
      clear_stdin
      read -e -p "Which column families do you want to flush? [ALL]: " cf
   fi

   echo
   echo "Running $nodetool_full flush $keyspace $cf..."
   $nodetool_full flush $keyspace $cf
   do_status $?
   press_any_key
   continue
}

do_cfstats_exec() {
   keyspace=""
   cf=""

   clear_stdin
   read -e -p "Which keyspace do you want cfstats? [ALL]: " keyspace

   if [ -n "$keyspace" ]; then
      clear_stdin
      read -e -p "Which column families do you want cfstats? [ALL]: " cf
      if [ -n "$cf" ]; then
         cf=".$cf"
      fi
   fi

   echo
   echo "Running $nodetool_full cfstats $keyspace$cf..."
   $nodetool_full cfstats "$keyspace$cf"
   do_status $?
   press_any_key
   continue
}

do_cfhistograms_exec() {
   keyspace=""
   cf=""

   clear_stdin
   read -e -p "Which keyspace do you want cfhistograms? [NONE]: " keyspace
   [ -z "$keyspace" ] && continue

   clear_stdin
   read -e -p "Which column family do you want cfhistograms? [NONE]: " cf
   [ -z "$cf" ] && continue

   echo
   echo "Running $nodetool_full cfhistograms $keyspace $cf..."
   $nodetool_full cfhistograms "$keyspace $cf"
   do_status $?
   press_any_key
   continue
}

do_compact_exec() {
   nodeid=""
   keyspace=""
   cf=""

   clear_stdin
   read -e -p "Which host do you want to compact? [NONE]: " nodeid
   [ -z "$nodeid" ] && continue
   clear_stdin
   read -e -p "Which keyspace do you want to compact? [ALL]: " keyspace

   if [ -n "$keyspace" ]; then
      clear_stdin
      read -e -p "Which column families do you want to compact? [ALL]: " cf
   fi

   nodetool_temp="$nodetool_cmd -h $nodeid"
   echo
   echo "Running $nodetool_temp compact $keyspace $cf..."
   echo
   nodetool_temp=$(append_auth "$nodetool_temp")
   $nodetool_temp compact $keyspace $cf
   do_status $?
   press_any_key
   continue
}

do_ring_exec() {
   keyspace=""

   clear_stdin
   read -e -p "Which keyspace do you want ring info? [ALL]: " keyspace

   echo
   echo "Running $nodetool_full ring $keyspace..."
   echo
   $nodetool_full ring $keyspace
   do_status $?
   press_any_key
   continue
}

# call nodetool -h nodeid option
read_host_and_exec() {
   option=$1

   [ -z "$option" ] && continue

   nodeid=""
   clear_stdin
   read -e -p "Which host do you want to $option? [NONE]: " nodeid
   [ -z "$nodeid" ] && continue
   nodetool_temp="$nodetool_cmd -h $nodeid"
   echo
   echo "Running $nodetool_temp $option..."
   echo
   nodetool_temp=$(append_auth "$nodetool_temp")
   $nodetool_temp $option
   do_status $?
   press_any_key
   continue
}

do_misc_G() {
   op=""
   PS3="Pick a number: "

   echo "Choose a cluster-wide reporting operation: "

   select op in getstreamthroughput getcompactionthroughput gossipinfo QUIT; do
      break
   done

   [ "$op" = "QUIT" ] && continue

   do_exec $op
}

do_misc_S() {
   op=""
   PS3="Pick a number: "

   echo "Choose a cluster-wide status operation: "

   select op in statusbinary statusthrift QUIT; do
      break
   done

   [ "$op" = "QUIT" ] && continue

   do_exec $op
}

do_misc_Z() {
   op=""
   PS3="Pick a number: "

   echo "Choose a node operation: "

   select op in enableautocompaction enablebackup enablebinary enablegossip enablehandoff enablethrift disableautocompaction disablebackup disablebinary disablegossip disablehandoff disablethrift pausehandoff resumehandoff QUIT; do
      break
   done

   [ "$op" = "QUIT" ] && continue

   read_host_and_exec $op
}

n_green='01;32'
n_red='01;31'
n_blue='01;34'

# use string functions to extract Cassandra version number
str=`$nodetool_full version`
c_version=${str##* }

# use string functions to extract cluster name, snitch and partitioner
str=`$nodetool_full describecluster`

regex="Name: (.*)
\s+Snitch: (.*Snitch)
\s+Partitioner: (.*)
\s+Schema versions:"

if [[ $str =~ $regex ]]; then
   c_name=${BASH_REMATCH[1]}
   c_snitch=${BASH_REMATCH[2]}
   c_snitch=${c_snitch##*.}
   c_partitioner=${BASH_REMATCH[3]}
   c_partitioner=${c_partitioner##*.}
   c_info="Cluster: $c_name v$c_version using $c_snitch/$c_partitioner"
else
   c_info="No cluster name found."
fi

TMOUT=$timeout

# animation to show screen is fresh
cursor="_"
progress=$cursor

while true; do
   # draw screen into an off-screen buffer to avoid apparent slow screen update lag
   out=`$nodetool_full status $2 |
      GREP_COLOR=$n_green $grep_cmd --color=always '^UN .*\|$' |
      GREP_COLOR=$n_red   $grep_cmd --color=always 'DN .*\|$' |
      GREP_COLOR=$n_blue  $grep_cmd --color=always '[UD][LJM] .*\|$'`

   out=${out/Note: Ownership information*specify a keyspace/} # remove informational message if user doesn't append a keyspace name

   if [ "$progress" = "$cursor" ]; then
      progress=" "
   else
      progress="$cursor"
   fi

   # ready to update screen now
   clear

   banner=$(do_banner)

   echo -e "$banner
$out
Press 'h' for help, 'q' to quit:$progress"

   TMOUT=$timeout # use the TMOUT envariable since read -t $timeout seems flaky
   in=""
   read -n 1 -s in
   TMOUT=0

   # Big Switch
   if [ "$in" = "c" ]; then # nodetool cfstats [keyspace].[column family]
      do_cfstats_exec 
   elif [ "$in" = "C" ]; then # nodetool cfhistograms keyspace column family
      do_cfhistograms_exec 
   elif [ "$in" = "d" ]; then # nodetool -h target_node drain
      read_host_and_exec drain
   elif [ "$in" = "f" ]; then # nodetool -h target_node flush [keyspace] [column families ...]
      do_flush_exec
   elif [ "$in" = "G" ]; then # misc get* nodetool commands
      do_misc_G
   elif [ "$in" = "h" ]; then # help
      do_help
   elif [ "$in" = "H" ]; then # nodetool -h target_node compactionhistory
      read_host_and_exec compactionhistory
   elif [ "$in" = "i" ]; then # nodetool -h target_node info
      read_host_and_exec info
   elif [ "$in" = "j" ]; then # nodetool -h target_node netstats
      read_host_and_exec join
   elif [ "$in" = "k" ]; then # nodetool -h target_node compact [keyspace] [column family ...]
      do_compact_exec
   elif [ "$in" = "K" ]; then # nodetool -h target_node getcompactionthroughput
      do_exec getcompactionthroughput
   elif [ "$in" = "l" ]; then # nodetool -h target_node getLoggingLevels
      read_host_and_exec getLoggingLevels
   elif [ "$in" = "n" ]; then # nodetool -h target_node netstats
      read_host_and_exec netstats
   elif [ "$in" = "p" ]; then # nodetool -h target_node proxyhistograms
      read_host_and_exec proxyhistograms
   elif [ "$in" = "q" ]; then # quit
      exit
   elif [ "$in" = "r" ]; then # nodetool ring [keyspace]
      do_ring_exec
   elif [ "$in" = "s" ]; then # nodetool -h target_node compactionstats
      read_host_and_exec compactionstats
   elif [ "$in" = "S" ]; then # misc status nodetool commands
      do_misc_S
   elif [ "$in" = "t" ]; then # nodetool tpstats
      do_exec tpstats
   elif [ "$in" = "Z" ]; then # misc enable and disable nodetool commands
      do_misc_Z
   else # other characters cause screen to update more quickly by skipping the sleep
      continue
   fi

   sleep $timeout
done

exit

